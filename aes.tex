\subsection{Пример использования полей и колец: алгоритм AES}
AES -- симметричный блочный шифр с фиксированной длиной блока шифруемых данных $128$ бит и переменной длиной ключа: $128$, $192$ или $256$ бит. В AES используется два типа данных: байты и слова. Одно слово равно $4$ байтам. Байт  $a_7a_6a_5a_4a_3a_2a_1a_0$ интерпретируется как многочлен
\begin{equation*}
a_7x^7+a_6x^6+a_5x^5+a_4x^4+a_3x^3+a_2x^2+a_1x+a_0
\end{equation*}
в поле  $GF(2^8)=GF(2)[x]/(x^8+x^4+x^3+x+1)$. Слово из четырех байт $(b_0,b_1,b_2,b_3)$ интерпретируется как многочлен 
\begin{equation*}
b_3z^3+b_2z^2+b_1z+b_0
\end{equation*}
в кольце  $GF(2^8)[z]/(z^4+1)$. Заметим, что  $z^4+1$ не является неприводимым многочленом над полем $GF(2^8)$, поэтому  $GF(2^8)[z]/(z^4+1)$ кольцо, а не поле.

Упражнение: перемножьте многочлены  $a(z)=a_3z^3+a_2z^2+a_1z+a_0$ и  $c(z)=c_3z^3+c_2z^2+c_1z+c_0$ 
в кольце  $GF(2^8)[z]/(z^4+1)$. Представьте результат умножения  $b(z)=a(z)c(z)$ в виде:
\begin{equation*}
\left[\begin{matrix}b_0\\b_1\\b_2\\b_3\end{matrix}\right]=\left[\begin{matrix}c_0&c_3&c_2&c_1\\c_1&c_0&c_3&c_2\\c_2&c_1&c_0&c_3\\c_3&c_2&c_1&c_0\end{matrix}\right]{\cdot}\left[\begin{matrix}a_0\\a_1\\a_2\\a_3\end{matrix}\right]
\end{equation*}
Промежуточный результат работы AES называется состоянием. Состояние может быть представлено как прямоугольный массив 

\begin{equation*}
S=(s_{{ij}})_{0\leq i\leq 3,0 \leq j \leq N_b-1}
\end{equation*}
байтов. В таком массиве четыре строки, а количество столбцов  $N_b$ равно длине блока в битах, делённой на $32$. В случае AES  $N_b=4$. AES является частным случаем алгоритма Rijndael, в котором параметр  $N_b$ может принимать и другие значения: $6$ и $8$.

Ключ шифра также можно представить в виде прямоугольного массива 

\begin{equation*}
K=(k_{ij})_{0{\leq}i{\leq}3,0{\leq}j{\leq}N_k-1}
\end{equation*}
с четырьмя строками. Количество столбцов в таком представлении ключа шифра обозначается  $N_k$ и равно длине ключа делённой на $32$, то есть  $N_k$ может принимать значения: $4$, $6$, $8$.

Столбцы состояния и ключа состоят из $4$ байт. Столбцы рассматривают как слова, то есть как элементы кольца  $GF(2^8)[z]/(z^4+1)$. 

Входная последовательность шифра отображается в байты состояния в порядке  $s_{0,0},s_{1,0},s_{2,0},s_{3,0},s_{0,1},s_{1,1},s_{2,1},s_{3,1},s_{4,1},{\ldots},$ ключ шифра отображается на массив в порядке  $k_{0,0},k_{1,0},k_{2,0},k_{3,0},k_{0,1},k_{1,1},k_{2,1},k_{3,1},k_{4,1},{\ldots}$.

Число раундов обозначается  $N_r$ и зависит от величин  $N_b$ и  $N_k$. Это показано в таблице:

\begin{equation*}
\begin{matrix}&N_k&N_b&N_r\\\mathit{AES}-128&4&4&10\\\mathit{AES}-192&6&4&12\\\mathit{AES}-256&8&4&14\end{matrix}
\end{equation*}
Шифрование AES на псевдокоде выглядит так:

\begin{verbatim}
Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr–1
        SubBytes(state)
        ShiftRows(state)
        MixColumns(state)
        AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
end
\end{verbatim}
Преобразование SubBytes осуществляет преобразование каждого байта состояния отдельно и следующим образом. Для байта  $a_7a_6a_5a_4a_3a_2a_1a_0$ берется мультипликативный обратный  $b_7b_6b_5b_4b_3b_2b_1b_0$ в поле  $GF(2^8)$. Затем  $b_7b_6b_5b_4b_3b_2b_1b_0$ преобразуется в  $b_7'b_6'b_5'b_4'b_3'b_2'b_1'b_0'$ следующим образом:

\begin{equation*}
b_i'=b_i{\oplus}b_{\left(i+4\right){\pmod 8}}{\oplus}b_{\left(i+5\right){\pmod 8}}{\oplus}b_{\left(i+6\right){\pmod 8}}{\oplus}b_{\left(i+7\right){\pmod 8}}{\oplus}c_i
\end{equation*}
\begin{equation*}
c=\left\{01100011\right\}=\left\{63\right\}
\end{equation*}
Другими словами:

\begin{equation*}
\left[\begin{matrix}b_0'\\b_1'\\b_2'\\b_3'\\b_4'\\b_5'\\b_6'\\b_7'\end{matrix}\right]=\left[\begin{matrix}1&0&0&0&1&1&1&1\\1&1&0&0&0&1&1&1\\1&1&1&0&0&0&1&1\\1&1&1&1&0&0&0&1\\1&1&1&1&1&0&0&0\\0&1&1&1&1&1&0&0\\0&0&1&1&1&1&1&0\\0&0&0&1&1&1&1&1\end{matrix}\right]{\cdot}\left[\begin{matrix}b_0\\b_1\\b_2\\b_3\\b_4\\b_5\\b_6\\b_7\end{matrix}\right]+\left[\begin{matrix}1\\1\\0\\0\\0\\1\\1\\0\end{matrix}\right]
\end{equation*}

При действии преобразования ShiftRows строки состояния циклически в таком порядке:  $\left(a_0,a_1,a_2,a_3\right)\rightarrow (a_1,a_2,a_3,a_0)$ сдвигаются на различное число байтов. Строка $0$ не сдвигается, строка $1$ сдвигается на  $C_1=1$ байт, строка $2$~-- на  $C_2=2$ байта и строка $3$~-- на  $C_3=3$ байта.

При преобразовании MixColumns столбцы cостояния рассматриваются как многочлены в кольце  $GF(2^8)[z]/(z^4+1)$ и умножаются на фиксированный многочлен  $c(z)$:

\begin{equation*}
с(z)=\left\{03\right\}z^3+\left\{01\right\}z^2+\{01\}z+\{02\}
\end{equation*}
Этот многочлен взаимно простой с  $z^4+1$ и поэтому обратим:

\begin{equation*}
c^{-1}(z)=\left\{0b\right\}z^3+\left\{0d\right\}z^2+\{09\}z+\{0e\}.
\end{equation*}
Обратимость важна для расшифровки.

Преобразование AddRoundKey прибавляет раундовый ключ к состоянию: соответствующие компоненты массивов состояния и ключа складываются в поле $GF(2^8)$, то есть путем простого побитового сложения по модулю $2$. Раундовый ключ берется из массива расширенного ключа, который строится из ключа шифра посредством следующего алгоритма расширение ключа. Расширенный ключ~-- это одномерный массив четырехбайтовых слов, обозначаемый  $w[N_b\ast (N_r+1)]$. Первые  $N_k$ слов содержат ключ шифра. Все остальные слова определяются рекурсивно через слова с меньшими индексами:

\begin{verbatim}
KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
begin
    word temp
    i = 0
    while (i < Nk)
        w[i] = word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3])
        i = i+1
    end while
    i = Nk
    while (i < Nb * (Nr+1)]
        temp = w[i-1]
        if (i mod Nk = 0)
             temp = SubWord(RotWord(temp)) xor Rcon[i/Nk]
        else if (Nk > 6 and i mod Nk = 4)
             temp = SubWord(temp)
        end if
        w[i] = w[i-Nk] xor temp
        i = i + 1
    end while
end
\end{verbatim}
Здесь SubWord -- функция, возвращающая четырехбайтовое слово, в котором каждый байт есть результат применения преобразования такого же как и в SubBytes к соответствующему байту во входном слове. Функция RotWord возвращает слово, в котором байты получены циклической перестановкой из байтов входного слова, таким образом, что входное слово  $(a,b,c,d)$ преобразуется в выходное  $(b,c,d,a)$. Раундовые константы Rcon определяются следующим образом:  $\mathit{Rcon}\left[i\right]=\left(x^{i-1},'00','00','00'\right)=\left('02','00','00','00'\right)$.

Упражнение: подумайте как осуществляется расшифровка в AES.
